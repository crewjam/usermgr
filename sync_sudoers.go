package usermgr

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os/exec"
	"regexp"
	"strings"
)

var sudoersFilePath = "/etc/sudoers.d/usermgr"

var sudoersUserNameRegexp = regexp.MustCompile("^[a-zA-Z0-9\\-\\_]+$")

func SyncSudoers(ud *UsersData, loginGroups []string, sudoGroups []string, dryRun bool) error {
	newSudoersFile := bytes.NewBuffer(nil)
	fmt.Fprintf(newSudoersFile, "# automatically generated by usermgr\n")
	for _, nominalUser := range ud.Users {
		if !sudoersUserNameRegexp.MatchString(nominalUser.Name) {
			return fmt.Errorf("user name %q not allowed in sudoers", nominalUser.Name)
		}
		if !nominalUser.InAnyGroup(loginGroups) {
			continue
		}
		fmt.Fprintf(newSudoersFile, "%s ALL=(%s) NOPASSWD: ALL\n", nominalUser.Name, nominalUser.Name)

		if nominalUser.InAnyGroup(sudoGroups) {
			fmt.Fprintf(newSudoersFile, "%s ALL=(ALL) NOPASSWD: ALL\n", nominalUser.Name)
		}
	}

	existingSudoersFile, err := ioutil.ReadFile(sudoersFilePath)
	if err == nil && bytes.Equal(existingSudoersFile, newSudoersFile.Bytes()) {
		// The file would not be changed, so don't mess with it
		return nil
	}

	// check the new file with visudo
	cmd := exec.Command("visudo", "-f", "-", "-c")
	cmd.Stdin = bytes.NewBuffer(newSudoersFile.Bytes())
	if checkOutput, err := cmd.CombinedOutput(); err != nil {
		// visudo will have printed output to stderr
		return fmt.Errorf("%s", strings.Replace(string(checkOutput), "\n", "; ", -1))
	}

	if dryRun {
		return nil
	}

	err = ioutil.WriteFile(sudoersFilePath, newSudoersFile.Bytes(), 0600)
	if err != nil {
		return err
	}
	return nil
}
