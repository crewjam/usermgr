package usermgr

import (
	"io/ioutil"
	"os"
	"regexp"

	. "gopkg.in/check.v1"
)

var _ = Suite(&TestSyncSudoers{})

type TestSyncSudoers struct {
	tempDir     string
	LoginGroups []string
	SudoGroups  []string
	DB          *UsersData
}

func (s *TestSyncSudoers) SetUpTest(c *C) {
	s.LoginGroups = []string{"global-admin", "myapp-admin", "global-user", "myapp-user"}
	s.SudoGroups = []string{"global-admin", "myapp-admin", "sudo-not-login"}
	s.DB = &UsersData{
		Users: []User{
			{
				Name:   "alice",
				Groups: []string{"myapp-admin"},
			},
		},
	}

	var err error
	s.tempDir, err = ioutil.TempDir("", "unittest")
	c.Assert(err, IsNil)

	sudoersFilePath = s.tempDir + "/sudoers"
}

func (s *TestSyncSudoers) TearDownTest(c *C) {
	os.RemoveAll(s.tempDir)
}

func (s *TestSyncSudoers) TestSyncSudoers(c *C) {
	var testCases = []struct {
		User   User
		Error  string
		Result string
	}{
		{
			User: User{
				Name:   "alice",
				Groups: []string{"myapp-admin"},
			},
			Result: "" +
				"# automatically generated by usermgr\n" +
				"alice ALL=(alice) NOPASSWD: ALL\n" +
				"alice ALL=(ALL) NOPASSWD: ALL\n",
		},
		{
			User: User{
				Name:   "alice",
				Groups: []string{"myapp-user"},
			},
			Result: "" +
				"# automatically generated by usermgr\n" +
				"alice ALL=(alice) NOPASSWD: ALL\n",
		},
		{
			User: User{
				Name:   "alice",
				Groups: []string{"irrelivent-group"},
			},
			Result: "" +
				"# automatically generated by usermgr\n",
		},
		{
			User: User{
				Name:   "alice",
				Groups: []string{"sudo-not-login"},
			},
			Result: "" +
				"# automatically generated by usermgr\n",
		},
		{
			User: User{
				Name:   "alice ALL=(ALL) NOPASSWD: ALL #",
				Groups: []string{"myapp-user"},
			},
			Error: "user name .* not allowed in sudoers",
		},
	}

	for _, testCase := range testCases {
		s.DB.Users = []User{testCase.User}

		err := SyncSudoers(s.DB, s.LoginGroups, s.SudoGroups, false)
		if testCase.Error != "" {
			c.Assert(err, ErrorMatches, testCase.Error)
			continue
		}
		c.Assert(err, IsNil)

		content, err := ioutil.ReadFile(sudoersFilePath)
		c.Assert(err, IsNil)
		c.Assert(string(content), Equals, testCase.Result)
	}
}

func (s *TestSyncSudoers) TestVisudoCheck(c *C) {
	oldSudoersUserNameRegexp := sudoersUserNameRegexp
	defer func() {
		sudoersUserNameRegexp = oldSudoersUserNameRegexp
	}()
	sudoersUserNameRegexp = regexp.MustCompile(".*")

	s.DB.Users = []User{
		User{
			Name:   "alice\n",
			Groups: []string{"myapp-user"},
		},
	}

	err := SyncSudoers(s.DB, s.LoginGroups, s.SudoGroups, false)
	c.Assert(err, ErrorMatches, ".*syntax error.*")
}

func (s *TestSyncSudoers) TestCannotWrite(c *C) {
	sudoersFilePath = "/dev/null~"
	err := SyncSudoers(s.DB, s.LoginGroups, s.SudoGroups, false)
	c.Assert(err, ErrorMatches, ".*permission denied.*")
}
